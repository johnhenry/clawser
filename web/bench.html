<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Clawser Benchmarks</title>
<style>
  body { font-family: monospace; background: #0d1117; color: #c9d1d9; padding: 20px; }
  .pass { color: #3fb950; }
  .warn { color: #d29922; }
  .section { color: #58a6ff; font-weight: bold; margin-top: 16px; }
  #results { white-space: pre-wrap; line-height: 1.6; }
  #summary { margin-top: 20px; padding: 10px; border-top: 1px solid #30363d; font-size: 16px; }
  .metric { color: #d2a8ff; }
</style>
</head>
<body>
<h2>Clawser Performance Benchmarks</h2>
<div id="results"></div>
<div id="summary"></div>

<script type="module">
import { extractCodeBlocks, stripCodeBlocks, Codex } from './clawser-codex.js';
import { ClawserAgent } from './clawser-agent.js';
import {
  BrowserToolRegistry, BrowserTool,
} from './clawser-tools.js';

const results = document.getElementById('results');
const benchmarks = [];

function section(name) {
  results.innerHTML += `\n<span class="section">── ${name} ──</span>\n`;
}

function bench(name, durationMs, ops, detail = '') {
  const opsPerSec = ops > 0 ? (ops / (durationMs / 1000)).toFixed(0) : 'N/A';
  benchmarks.push({ name, durationMs, ops, opsPerSec });
  results.innerHTML += `<span class="pass">  ${name}</span>\n`;
  results.innerHTML += `    <span class="metric">Duration: ${durationMs.toFixed(2)}ms | Ops: ${ops} | Ops/sec: ${opsPerSec}</span>\n`;
  if (detail) {
    results.innerHTML += `    <span class="metric">${detail}</span>\n`;
  }
}

// ═══════════════════════════════════════════════════════════════
//  Benchmark 1: Codex Code Block Extraction
// ═══════════════════════════════════════════════════════════════

section('Codex — Code Block Extraction');

{
  const sampleResponse = `Here is some code:

\`\`\`js
const x = 1 + 2;
print(x);
\`\`\`

And here is more:

\`\`\`tool_code
const y = await browser_fetch({url: "https://example.com"});
print(y);
\`\`\`
`;

  const iterations = 1000;
  const t0 = performance.now();
  for (let i = 0; i < iterations; i++) {
    extractCodeBlocks(sampleResponse);
  }
  const t1 = performance.now();
  bench('extractCodeBlocks (1000 iterations)', t1 - t0, iterations);

  const t2 = performance.now();
  for (let i = 0; i < iterations; i++) {
    stripCodeBlocks(sampleResponse);
  }
  const t3 = performance.now();
  bench('stripCodeBlocks (1000 iterations)', t3 - t2, iterations);
}

// ═══════════════════════════════════════════════════════════════
//  Benchmark 2: EventLog Append/Load Speed
// ═══════════════════════════════════════════════════════════════

section('EventLog — Append & Serialize (500 events)');

{
  // Import EventLog indirectly through ClawserAgent's module
  // We test the EventLog pattern manually since it's not exported directly
  const EVENT_COUNT = 500;
  const events = [];

  // Benchmark: append 500 events
  const t0 = performance.now();
  let seq = 0;
  for (let i = 0; i < EVENT_COUNT; i++) {
    events.push({
      id: `evt_${Date.now()}_${seq++}`,
      type: i % 3 === 0 ? 'user_message' : i % 3 === 1 ? 'agent_message' : 'tool_call',
      timestamp: Date.now(),
      data: {
        role: i % 2 === 0 ? 'user' : 'assistant',
        content: `Message number ${i} with some reasonable content length to simulate real usage.`,
      },
      source: i % 2 === 0 ? 'user' : 'agent',
    });
  }
  const t1 = performance.now();
  bench(`Append ${EVENT_COUNT} events`, t1 - t0, EVENT_COUNT);

  // Benchmark: serialize to JSONL
  const t2 = performance.now();
  const jsonl = events.map(e => JSON.stringify(e)).join('\n');
  const t3 = performance.now();
  bench(`Serialize ${EVENT_COUNT} events to JSONL`, t3 - t2, EVENT_COUNT,
    `Output size: ${(jsonl.length / 1024).toFixed(1)} KB`);

  // Benchmark: deserialize from JSONL
  const t4 = performance.now();
  const lines = jsonl.trim().split('\n').filter(Boolean);
  const parsed = lines.map(line => JSON.parse(line));
  const t5 = performance.now();
  bench(`Deserialize ${EVENT_COUNT} events from JSONL`, t5 - t4, parsed.length);
}

// ═══════════════════════════════════════════════════════════════
//  Benchmark 3: Tool Registry Lookup (100 tools)
// ═══════════════════════════════════════════════════════════════

section('Tool Registry — Register & Lookup (100 tools)');

{
  const TOOL_COUNT = 100;
  const reg = new BrowserToolRegistry();

  // Dynamically create 100 tool classes
  const toolNames = [];
  const t0 = performance.now();
  for (let i = 0; i < TOOL_COUNT; i++) {
    const toolName = `bench_tool_${String(i).padStart(3, '0')}`;
    toolNames.push(toolName);
    // Create tool using a closure over the name
    const tool = Object.create(BrowserTool.prototype);
    Object.defineProperties(tool, {
      name: { get() { return toolName; } },
      description: { get() { return `Benchmark tool ${i}`; } },
      parameters: { get() { return { type: 'object', properties: { x: { type: 'number' } }, required: ['x'] }; } },
      execute: { value: async ({ x }) => ({ success: true, output: String(x) }) },
    });
    reg.register(tool);
  }
  const t1 = performance.now();
  bench(`Register ${TOOL_COUNT} tools`, t1 - t0, TOOL_COUNT);

  // Benchmark: lookup each tool by name
  const LOOKUP_ITERATIONS = 10000;
  const t2 = performance.now();
  for (let i = 0; i < LOOKUP_ITERATIONS; i++) {
    const name = toolNames[i % TOOL_COUNT];
    reg.get(name);
  }
  const t3 = performance.now();
  bench(`Lookup tools (${LOOKUP_ITERATIONS} iterations)`, t3 - t2, LOOKUP_ITERATIONS);

  // Benchmark: has() check
  const t4 = performance.now();
  for (let i = 0; i < LOOKUP_ITERATIONS; i++) {
    const name = toolNames[i % TOOL_COUNT];
    reg.has(name);
  }
  const t5 = performance.now();
  bench(`has() check (${LOOKUP_ITERATIONS} iterations)`, t5 - t4, LOOKUP_ITERATIONS);

  // Benchmark: names() listing
  const t6 = performance.now();
  for (let i = 0; i < 1000; i++) {
    reg.names();
  }
  const t7 = performance.now();
  bench('names() listing (1000 iterations)', t7 - t6, 1000);

  // Benchmark: allSpecs() generation
  const t8 = performance.now();
  for (let i = 0; i < 100; i++) {
    reg.allSpecs();
  }
  const t9 = performance.now();
  bench('allSpecs() generation (100 iterations)', t9 - t8, 100,
    `${TOOL_COUNT} tools per call`);
}

// ═══════════════════════════════════════════════════════════════
//  SUMMARY
// ═══════════════════════════════════════════════════════════════

const summary = document.getElementById('summary');
const totalDuration = benchmarks.reduce((sum, b) => sum + b.durationMs, 0);
summary.innerHTML = `<span class="pass">All ${benchmarks.length} benchmarks completed in ${totalDuration.toFixed(1)}ms</span>`;

// Expose results for programmatic access
window.__benchResults = {
  total: benchmarks.length,
  totalDurationMs: totalDuration,
  benchmarks: benchmarks.map(b => ({
    name: b.name,
    durationMs: b.durationMs,
    ops: b.ops,
    opsPerSec: b.opsPerSec,
  })),
};

console.log(`Benchmarks: ${benchmarks.length} completed, total ${totalDuration.toFixed(1)}ms`);
</script>
</body>
</html>
